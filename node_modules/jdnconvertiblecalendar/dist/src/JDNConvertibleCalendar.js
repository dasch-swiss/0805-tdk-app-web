"use strict";
/*
 * Copyright © 2018 Lukas Rosenthaler, Rita Gautschy, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and Sepideh Alassi.
 *
 * This file is part of JDNConvertibleCalendar.
 *
 * JDNConvertibleCalendar is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JDNConvertibleCalendar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with JDNConvertibleCalendar.  If not, see <http://www.gnu.org/licenses/>.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var JDNCalendarConversion_1 = require("./JDNCalendarConversion");
var JDNConvertibleCalendarModule;
(function (JDNConvertibleCalendarModule) {
    /**
     * Checks if a given number is an integer.
     *
     * @param num number to check for.
     * @returns true if the given number is an integer, returns false otherwise.
     */
    var isInteger = function (num) {
        // https://stackoverflow.com/questions/3885817/how-do-i-check-that-a-number-is-float-or-integer
        return num % 1 === 0;
    };
    /**
     * Represents an error that occurred when using `JDNConvertibleCalendarModule`.
     */
    var JDNConvertibleCalendarError = /** @class */ (function (_super) {
        __extends(JDNConvertibleCalendarError, _super);
        /**
         *
         * @param message description of the error.
         */
        function JDNConvertibleCalendarError(message) {
            return _super.call(this, message) || this;
        }
        return JDNConvertibleCalendarError;
    }(Error));
    JDNConvertibleCalendarModule.JDNConvertibleCalendarError = JDNConvertibleCalendarError;
    /**
     * Represents a calendar date (calendar agnostic).
     *
     * Assumes that every supported calendar
     * can be represented by a combination of year, month, and day.
     *
     */
    var CalendarDate = /** @class */ (function () {
        /**
         *
         * Please note that this software uses the (astronomical) convention that BCE dates are represented as negative years and that the year zero (0) is used.
         * The year 1 BCE must be indicated as year 0, and the year 2 BCE corresponds to -1 etc.
         *
         * @param year year of the given date.
         * @param month month of the given date.
         * @param day day of the given date (day of month, 1 based index).
         * @param dayOfWeek day of week of the given date (0 based index), if any.
         * @param daytime time of the day (0 - 0.9…), if any. 0 refers to midnight, 0.5 to noon, 0.9… to midnight of the same day. 1 would already refer to the next day and is thus not valid.
         */
        function CalendarDate(year, month, day, dayOfWeek, daytime) {
            this.year = year;
            this.month = month;
            this.day = day;
            this.dayOfWeek = dayOfWeek;
            this.daytime = daytime;
            // check validity of daytime
            if (daytime !== undefined && daytime >= 1)
                throw new JDNConvertibleCalendarError('Invalid daytime: ' + daytime + ', valid range: 0 - 0.9…');
            // TODO: When other calendar than Gregorian or Julian are implemented, this may have to be changed
            if (dayOfWeek !== undefined && (!isInteger(dayOfWeek) || dayOfWeek < 0 || dayOfWeek > 6))
                throw new JDNConvertibleCalendarError('Invalid day of week: ' + dayOfWeek);
        }
        return CalendarDate;
    }());
    JDNConvertibleCalendarModule.CalendarDate = CalendarDate;
    /**
     * Represents a period as two calendar dates.
     */
    var CalendarPeriod = /** @class */ (function () {
        /**
         *
         * @param periodStart start of the period.
         * @param periodEnd End of the period.
         */
        function CalendarPeriod(periodStart, periodEnd) {
            // TODO: can we check that periodStart equals or is before periodEnd?
            this.periodStart = periodStart;
            this.periodEnd = periodEnd;
        }
        return CalendarPeriod;
    }());
    JDNConvertibleCalendarModule.CalendarPeriod = CalendarPeriod;
    /**
     * Represents a period as two JDNs.
     */
    var JDNPeriod = /** @class */ (function () {
        /**
         *
         * @param periodStart start of the period.
         * @param periodEnd End of the period.
         */
        function JDNPeriod(periodStart, periodEnd) {
            this.periodStart = periodStart;
            this.periodEnd = periodEnd;
            // check that periodStart equals or is before periodEnd
            if (periodStart > periodEnd)
                throw new JDNConvertibleCalendarError("start of a JDNPeriod must not be greater than its end");
            // check that given arguments are integers (JDNs have no fractions)
            if (!(isInteger(periodStart) && isInteger(periodEnd))) {
                throw new JDNConvertibleCalendarError('JDNs are expected to be integers');
            }
            this.exactDate = (periodStart === periodEnd);
        }
        return JDNPeriod;
    }());
    JDNConvertibleCalendarModule.JDNPeriod = JDNPeriod;
    /**
     * Abstract class representing any calendar
     * that can be converted from and to a Julian Day.
     */
    var JDNConvertibleCalendar = /** @class */ (function () {
        function JDNConvertibleCalendar(period) {
            // initialize members (required by TypeScript compiler)
            var julianPeriodStart = new CalendarDate(-4712, 1, 1);
            this.calendarStart = julianPeriodStart;
            this.calendarEnd = julianPeriodStart;
            this.exactDate = true;
            this.jdnStart = 0;
            this.jdnEnd = 0;
            if (period instanceof JDNPeriod) {
                // period is a JDNPeriod
                this.convertJDNPeriodToCalendarPeriod(period);
            }
            else {
                // period is a CalendarPeriod
                var jdnStart = this.calendarToJDN(period.periodStart);
                var jdnEnd = this.calendarToJDN(period.periodEnd);
                this.convertJDNPeriodToCalendarPeriod(new JDNPeriod(jdnStart, jdnEnd));
            }
        }
        /**
         * Calculates number of days for the month of the given date.
         *
         * The given date is expected to be of the same calendar as the instance the method is called on.
         *
         * @param date given date.
         * @returns number of days in month of given date.
         */
        JDNConvertibleCalendar.prototype.daysInMonth = function (date) {
            // get JDN for first day of the month of the given calendar date
            var firstDayOfGivenMonth = this.calendarToJDN(new CalendarDate(date.year, date.month, 1));
            // first day of next month
            var firstDayOfNextMonth;
            // if the given date is in the last month of the year, switch to first day of the first month the next year.
            if ((date.month + 1) > this.monthsInYear) {
                firstDayOfNextMonth = this.calendarToJDN(new CalendarDate(date.year + 1, 1, 1));
            }
            else {
                // switch to the first day of the next month
                firstDayOfNextMonth = this.calendarToJDN(new CalendarDate(date.year, date.month + 1, 1));
            }
            // calculate the difference between the first day of the month of the given day
            // and the first day of the next month -> number of days of the month of the given date
            return firstDayOfNextMonth - firstDayOfGivenMonth;
        };
        /**
         * Converts the given JDN period to a calendar period and stores it.
         *
         * This method makes sure that JDNs and calendar dates are in sync. This method has no return value,
         * it manipulates `this.calendarStart`, and `this.calendarEnd` instead.
         *
         * Do not manipulate members `this.exactDate`, `this.jdnStart`, `this.jdnEnd`, `this.calendarStart`, and `this.calendarEnd` directly,
         * use this method instead.
         *
         * @param jdnPeriod the period defined by JDNs to be converted to a calendar period.
         */
        JDNConvertibleCalendar.prototype.convertJDNPeriodToCalendarPeriod = function (jdnPeriod) {
            this.exactDate = jdnPeriod.exactDate;
            this.jdnStart = jdnPeriod.periodStart;
            this.jdnEnd = jdnPeriod.periodEnd;
            // check if the date is exact (start of period equals end of period)
            if (this.exactDate) {
                // only one conversion needed
                var date = this.JDNToCalendar(jdnPeriod.periodStart);
                // calculate the day of the week
                var dayOfWeek = this.dayOfWeekFromJDN(jdnPeriod.periodStart);
                var dateWithDayOfWeek = new CalendarDate(date.year, date.month, date.day, dayOfWeek);
                this.calendarStart = dateWithDayOfWeek;
                this.calendarEnd = dateWithDayOfWeek;
            }
            else {
                // calculate the days of the week
                var dayOfWeekStart = this.dayOfWeekFromJDN(jdnPeriod.periodStart);
                var dayOfWeekEnd = this.dayOfWeekFromJDN(jdnPeriod.periodEnd);
                var dateStart = this.JDNToCalendar(jdnPeriod.periodStart);
                var dateEnd = this.JDNToCalendar(jdnPeriod.periodEnd);
                // calculate calendar dates for both start and end of period
                this.calendarStart = new CalendarDate(dateStart.year, dateStart.month, dateStart.day, dayOfWeekStart);
                this.calendarEnd = new CalendarDate(dateEnd.year, dateEnd.month, dateEnd.day, dayOfWeekEnd);
            }
        };
        /**
         * Returns the given period as two calendar dates.
         *
         * @returns period consisting of two calendar dates.
         */
        JDNConvertibleCalendar.prototype.toCalendarPeriod = function () {
            return new CalendarPeriod(this.calendarStart, this.calendarEnd);
        };
        /**
         * Converts an instance of `JDNConvertibleCalendar` to a `JDNPeriod`.
         *
         * @returns period consisting of two JDNs.
         */
        JDNConvertibleCalendar.prototype.toJDNPeriod = function () {
            return new JDNPeriod(this.jdnStart, this.jdnEnd);
        };
        /**
         * Converts from one calendar into another.
         *
         * To be extended when new subclasses are added.
         *
         * @param {"Gregorian" | "Julian"} toCalendarType calendar to convert to.
         * @returns instance of target calendar (subclass of `JDNConvertibleCalendar`).
         */
        JDNConvertibleCalendar.prototype.convertCalendar = function (toCalendarType) {
            if (JDNConvertibleCalendar.supportedCalendars.indexOf(toCalendarType) == -1) {
                throw new JDNConvertibleCalendarError('Target calendar not supported: ' + toCalendarType);
            }
            if (this.calendarName == toCalendarType)
                return this; // no conversion needed
            var jdnPeriod = this.toJDNPeriod();
            // call constructor of subclass representing the target calendar
            switch (toCalendarType) {
                case JDNConvertibleCalendar.gregorian:
                    return new GregorianCalendarDate(jdnPeriod);
                case JDNConvertibleCalendar.julian:
                    return new JulianCalendarDate(jdnPeriod);
            }
        };
        /**
         * Transposes the current period by the given number of days.
         *
         * @param days the number of days that the current period will be shifted.
         */
        JDNConvertibleCalendar.prototype.transposePeriodByDay = function (days) {
            if (days === 0)
                return;
            if (!isInteger(days))
                throw new JDNConvertibleCalendarError("parameter \"days\" is expected to be an integer");
            var currentPeriod = this.toJDNPeriod();
            var newPeriod = new JDNPeriod(currentPeriod.periodStart + days, currentPeriod.periodEnd + days);
            this.convertJDNPeriodToCalendarPeriod(newPeriod);
        };
        /**
         * Transposes the current period by the given number of years.
         *
         * This method is not accurate in the arithmetical sense: it tries to fit the given day in the month of the new year.
         * If this is not possible, it takes the last day of the new month (e.g., February 29 will become the last possible day of February).
         *
         * @param years the number of years that the current period will be shifted.
         */
        JDNConvertibleCalendar.prototype.transposePeriodByYear = function (years) {
            if (years === 0)
                return;
            if (!isInteger(years))
                throw new JDNConvertibleCalendarError("parameter \"years\" is expected to be an integer");
            var currentCalendarPeriod = this.toCalendarPeriod();
            var newJDNPeriod;
            // indicates if the shifting is towards the future or the past
            var intoTheFuture = (years > 0);
            if (this.exactDate) {
                var yearZeroCorrection = 0;
                // when switching from a negative to a negative year and the year zero does not exist in the calendar used, correct it.
                if (!this.yearZeroExists && intoTheFuture && currentCalendarPeriod.periodStart.year < 1 && (currentCalendarPeriod.periodStart.year + years > -1)) {
                    yearZeroCorrection = 1;
                    // when switching from a positive to a negative year and the year zero does not exist in the calendar used, correct it.
                }
                else if (!this.yearZeroExists && !intoTheFuture && currentCalendarPeriod.periodStart.year > -1 && (currentCalendarPeriod.periodStart.year + years < 1)) {
                    yearZeroCorrection = -1;
                }
                // determine max. number of days in the new month
                var maxDaysInNewMonth = this.daysInMonth(new CalendarDate(currentCalendarPeriod.periodStart.year + years + yearZeroCorrection, currentCalendarPeriod.periodStart.month, 1));
                var newCalendarDate = new CalendarDate(currentCalendarPeriod.periodStart.year + years + yearZeroCorrection, currentCalendarPeriod.periodStart.month, (currentCalendarPeriod.periodStart.day > maxDaysInNewMonth) ? maxDaysInNewMonth : currentCalendarPeriod.periodStart.day);
                var newJDN = this.calendarToJDN(newCalendarDate);
                newJDNPeriod = new JDNPeriod(newJDN, newJDN);
            }
            else {
                var yearZeroCorrectionStart = 0;
                // when switching from a negative to a negative year and the year zero does not exist in the calendar used, correct it.
                if (!this.yearZeroExists && intoTheFuture && currentCalendarPeriod.periodStart.year < 1 && (currentCalendarPeriod.periodStart.year + years > -1)) {
                    yearZeroCorrectionStart = 1;
                    // when switching from a positive to a negative year and the year zero does not exist in the calendar used, correct it.
                }
                else if (!this.yearZeroExists && !intoTheFuture && currentCalendarPeriod.periodStart.year > -1 && (currentCalendarPeriod.periodStart.year + years < 1)) {
                    yearZeroCorrectionStart = -1;
                }
                // determine max. number of days in the new month
                var maxDaysInNewMonthStart = this.daysInMonth(new CalendarDate(currentCalendarPeriod.periodStart.year + years + yearZeroCorrectionStart, currentCalendarPeriod.periodStart.month, 1));
                var newCalendarDateStart = new CalendarDate(currentCalendarPeriod.periodStart.year + years + yearZeroCorrectionStart, currentCalendarPeriod.periodStart.month, (currentCalendarPeriod.periodStart.day > maxDaysInNewMonthStart) ? maxDaysInNewMonthStart : currentCalendarPeriod.periodStart.day);
                var newJDNStart = this.calendarToJDN(newCalendarDateStart);
                var yearZeroCorrectionEnd = 0;
                // when switching from a negative to a negative year and the year zero does not exist in the calendar used, correct it.
                if (!this.yearZeroExists && intoTheFuture && currentCalendarPeriod.periodEnd.year < 1 && (currentCalendarPeriod.periodEnd.year + years > -1)) {
                    yearZeroCorrectionEnd = 1;
                    // when switching from a positive to a negative year and the year zero does not exist in the calendar used, correct it.
                }
                else if (!this.yearZeroExists && !intoTheFuture && currentCalendarPeriod.periodEnd.year > -1 && (currentCalendarPeriod.periodEnd.year + years < 1)) {
                    yearZeroCorrectionEnd = -1;
                }
                // determine max. number of days in the new month
                var maxDaysInNewMonthEnd = this.daysInMonth(new CalendarDate(currentCalendarPeriod.periodEnd.year + years + yearZeroCorrectionEnd, currentCalendarPeriod.periodEnd.month, 1));
                var newCalendarDateEnd = new CalendarDate(currentCalendarPeriod.periodEnd.year + years + yearZeroCorrectionEnd, currentCalendarPeriod.periodEnd.month, (currentCalendarPeriod.periodEnd.day > maxDaysInNewMonthEnd) ? maxDaysInNewMonthEnd : currentCalendarPeriod.periodEnd.day);
                var newJDNEnd = this.calendarToJDN(newCalendarDateEnd);
                newJDNPeriod = new JDNPeriod(newJDNStart, newJDNEnd);
            }
            this.convertJDNPeriodToCalendarPeriod(newJDNPeriod);
        };
        /**
         * Converts the given calendar date to a new one, shifting the months by the given number.
         *
         * @param calendarDate the given calendar date.
         * @param months the number of months to shift.
         * @returns calendar transposed by the given number of months.
         */
        JDNConvertibleCalendar.prototype.handleMonthTransposition = function (calendarDate, months) {
            if (months === 0)
                return calendarDate;
            if (!isInteger(months))
                throw new JDNConvertibleCalendarError("parameter \"months\" is expected to be an integer");
            // indicates if the shifting is towards the future or the past
            var intoTheFuture = (months > 0);
            // get number of full years to shift
            var yearsToShift = Math.floor(Math.abs(months) / this.monthsInYear);
            // get remaining months to shift: max. this.monthsInYear - 1
            var monthsToShift = Math.abs(months) % this.monthsInYear;
            var newCalendarDate;
            if (intoTheFuture) {
                // switch to the next year if the number of months does not fit
                if (calendarDate.month + monthsToShift > this.monthsInYear) {
                    // months to be added to new year
                    var monthsOverflow = calendarDate.month + monthsToShift - this.monthsInYear;
                    // when switching from a negative to a negative year and the year zero does not exist in the calendar used, correct it.
                    var yearZeroCorrection = 0;
                    if (!this.yearZeroExists && calendarDate.year < 1 && (calendarDate.year + yearsToShift + 1 > -1)) {
                        yearZeroCorrection = 1;
                    }
                    // determine max. number of days in the new month
                    var maxDaysInNewMonth = this.daysInMonth(new CalendarDate(calendarDate.year + yearsToShift + 1 + yearZeroCorrection, monthsOverflow, 1));
                    newCalendarDate = new CalendarDate(calendarDate.year + yearsToShift + 1 + yearZeroCorrection, // add an extra year
                    monthsOverflow, (calendarDate.day > maxDaysInNewMonth) ? maxDaysInNewMonth : calendarDate.day);
                }
                else {
                    // determine max. number of days in the new month
                    var maxDaysInNewMonth = this.daysInMonth(new CalendarDate(calendarDate.year + yearsToShift, calendarDate.month + monthsToShift, 1));
                    newCalendarDate = new CalendarDate(calendarDate.year + yearsToShift, calendarDate.month + monthsToShift, (calendarDate.day > maxDaysInNewMonth) ? maxDaysInNewMonth : calendarDate.day);
                }
            }
            else {
                // switch to the previous year if the number of months does not fit
                if (calendarDate.month - monthsToShift < 1) {
                    // months to be subtracted from the previous year
                    var newMonth = this.monthsInYear - (monthsToShift - calendarDate.month);
                    // when switching from a positive to a negative year and the year zero does not exist in the calendar used, correct it.
                    var yearZeroCorrection = 0;
                    if (!this.yearZeroExists && calendarDate.year > -1 && (calendarDate.year - yearsToShift - 1 < 1)) {
                        yearZeroCorrection = -1;
                    }
                    // determine max. number of days in the new month
                    var maxDaysInNewMonth = this.daysInMonth(new CalendarDate(calendarDate.year - yearsToShift - 1 + yearZeroCorrection, newMonth, 1));
                    newCalendarDate = new CalendarDate(calendarDate.year - yearsToShift - 1 + yearZeroCorrection, // subtract an extra year
                    newMonth, (calendarDate.day > maxDaysInNewMonth) ? maxDaysInNewMonth : calendarDate.day);
                }
                else {
                    // determine max. number of days in the new month
                    var maxDaysInNewMonth = this.daysInMonth(new CalendarDate(calendarDate.year - yearsToShift, calendarDate.month - monthsToShift, 1));
                    newCalendarDate = new CalendarDate(calendarDate.year - yearsToShift, calendarDate.month - monthsToShift, (calendarDate.day > maxDaysInNewMonth) ? maxDaysInNewMonth : calendarDate.day);
                }
            }
            return newCalendarDate;
        };
        /**
         * Transposes the current period by the given number of months.
         *
         * This method is not accurate in the arithmetical sense: it tries to fit the given day in the new month.
         * If this is not possible, it takes the last day of the new month (e.g., January 31 will become the last possible day of February).
         *
         * @param months the number of months that the current period will be shifted.
         */
        JDNConvertibleCalendar.prototype.transposePeriodByMonth = function (months) {
            if (months === 0)
                return;
            if (!isInteger(months))
                throw new JDNConvertibleCalendarError("parameter \"months\" is expected to be an integer");
            var currentCalendarPeriod = this.toCalendarPeriod();
            var newJDNPeriod;
            if (this.exactDate) {
                var newCalDate = this.handleMonthTransposition(currentCalendarPeriod.periodStart, months);
                var newJDN = this.calendarToJDN(newCalDate);
                newJDNPeriod = new JDNPeriod(newJDN, newJDN);
            }
            else {
                var newCalDateStart = this.handleMonthTransposition(currentCalendarPeriod.periodStart, months);
                var newJDNStart = this.calendarToJDN(newCalDateStart);
                var newCalDateEnd = this.handleMonthTransposition(currentCalendarPeriod.periodEnd, months);
                var newJDNEnd = this.calendarToJDN(newCalDateEnd);
                newJDNPeriod = new JDNPeriod(newJDNStart, newJDNEnd);
            }
            this.convertJDNPeriodToCalendarPeriod(newJDNPeriod);
        };
        /**
         * Constant for the Gregorian calendar.
         */
        JDNConvertibleCalendar.gregorian = 'Gregorian';
        /**
         * Constant for the Julian calendar.
         */
        JDNConvertibleCalendar.julian = 'Julian';
        /**
         * Supported calendars (to be extended when new subclasses are implemented).
         */
        JDNConvertibleCalendar.supportedCalendars = [JDNConvertibleCalendar.gregorian, JDNConvertibleCalendar.julian];
        return JDNConvertibleCalendar;
    }());
    JDNConvertibleCalendarModule.JDNConvertibleCalendar = JDNConvertibleCalendar;
    /**
     * Represents a Gregorian calendar date.
     */
    var GregorianCalendarDate = /** @class */ (function (_super) {
        __extends(GregorianCalendarDate, _super);
        function GregorianCalendarDate() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.calendarName = JDNConvertibleCalendar.gregorian;
            _this.monthsInYear = 12;
            // We use a calendar conversion methods that use the convention
            // that the year zero exists in the Gregorian Calendar.
            _this.yearZeroExists = true;
            return _this;
        }
        GregorianCalendarDate.prototype.JDNToCalendar = function (jdn) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.JDNToGregorian(jdn);
        };
        ;
        GregorianCalendarDate.prototype.calendarToJDN = function (date) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.gregorianToJDN(date);
        };
        GregorianCalendarDate.prototype.dayOfWeekFromJDN = function (jdn) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.dayOfWeekFromJDC(jdn);
        };
        ;
        return GregorianCalendarDate;
    }(JDNConvertibleCalendar));
    JDNConvertibleCalendarModule.GregorianCalendarDate = GregorianCalendarDate;
    /**
     * Represents a Julian calendar date.
     */
    var JulianCalendarDate = /** @class */ (function (_super) {
        __extends(JulianCalendarDate, _super);
        function JulianCalendarDate() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.calendarName = JDNConvertibleCalendar.julian;
            _this.monthsInYear = 12;
            // We use a calendar conversion methods that use the convention
            // that the year zero does exist in the Julian Calendar.
            _this.yearZeroExists = true;
            return _this;
        }
        JulianCalendarDate.prototype.JDNToCalendar = function (jdn) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.JDNToJulian(jdn);
        };
        JulianCalendarDate.prototype.calendarToJDN = function (date) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.julianToJDN(date);
        };
        JulianCalendarDate.prototype.dayOfWeekFromJDN = function (jdn) {
            return JDNCalendarConversion_1.JDNConvertibleConversionModule.dayOfWeekFromJDC(jdn);
        };
        ;
        return JulianCalendarDate;
    }(JDNConvertibleCalendar));
    JDNConvertibleCalendarModule.JulianCalendarDate = JulianCalendarDate;
})(JDNConvertibleCalendarModule = exports.JDNConvertibleCalendarModule || (exports.JDNConvertibleCalendarModule = {}));
