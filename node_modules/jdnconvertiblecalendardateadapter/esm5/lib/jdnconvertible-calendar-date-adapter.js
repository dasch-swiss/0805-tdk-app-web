/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*
 * Copyright © 2017 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and Sepideh Alassi.
 *
 * This file is part of JDNConvertibleCalendarDateAdapter.
 *
 * JDNConvertibleCalendarDateAdapter is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JDNConvertibleCalendarDateAdapter is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with JDNConvertibleCalendarDateAdapter.  If not, see <http://www.gnu.org/licenses/>.
 */
import { Injectable } from '@angular/core';
import { DateAdapter } from '@angular/material';
import { CalendarDate, CalendarPeriod, GregorianCalendarDate, JDNConvertibleCalendar, JulianCalendarDate } from 'jdnconvertiblecalendar';
var JDNConvertibleCalendarDateAdapter = /** @class */ (function (_super) {
    tslib_1.__extends(JDNConvertibleCalendarDateAdapter, _super);
    function JDNConvertibleCalendarDateAdapter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // the currently active calendar format
        _this._activeCalendarFormat = 'Gregorian';
        return _this;
    }
    Object.defineProperty(JDNConvertibleCalendarDateAdapter.prototype, "activeCalendarFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._activeCalendarFormat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds leading zeros to a given number and returns the resulting string.
     *
     * @param num the given number.
     * @param digits the number of expected digits.
     * @returns string containing leading zeros.
     */
    /**
     * Adds leading zeros to a given number and returns the resulting string.
     *
     * @private
     * @param {?} num the given number.
     * @param {?} digits the number of expected digits.
     * @return {?} string containing leading zeros.
     */
    JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber = /**
     * Adds leading zeros to a given number and returns the resulting string.
     *
     * @private
     * @param {?} num the given number.
     * @param {?} digits the number of expected digits.
     * @return {?} string containing leading zeros.
     */
    function (num, digits) {
        /** @type {?} */
        var missingDigits = digits - String(num).length;
        if (missingDigits > 0) {
            /** @type {?} */
            var leadingZeros = '';
            for (var i = 0; i < missingDigits; i++) {
                leadingZeros += '0';
            }
            return "" + leadingZeros + num;
        }
        else {
            return String(num);
        }
    };
    /**
     * Converts the given date to the indicated calendar format.
     *
     * @param date the date to be converted.
     * @param format the calendar format to convert to.
     * @returns converted date.
     */
    /**
     * Converts the given date to the indicated calendar format.
     *
     * @param {?} date the date to be converted.
     * @param {?} format the calendar format to convert to.
     * @return {?} converted date.
     */
    JDNConvertibleCalendarDateAdapter.prototype.convertCalendarFormat = /**
     * Converts the given date to the indicated calendar format.
     *
     * @param {?} date the date to be converted.
     * @param {?} format the calendar format to convert to.
     * @return {?} converted date.
     */
    function (date, format) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        /** @type {?} */
        var dateMod = this.clone(date);
        switch (format) {
            case 'Gregorian':
                this._activeCalendarFormat = 'Gregorian';
                return dateMod.convertCalendar('Gregorian');
            case 'Julian':
                this._activeCalendarFormat = 'Julian';
                return dateMod.convertCalendar('Julian');
            default:
                // invalid format
                return dateMod;
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getYear = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.toCalendarPeriod().periodStart.year;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getMonth = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // return 0 index based month
        return date.toCalendarPeriod().periodStart.month - 1;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return date.toCalendarPeriod().periodStart.day;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getDayOfWeek = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // dayOfWeek is an optional class member, but always set when returned by this method
        /** @type {?} */
        var dayOfWeek = date.toCalendarPeriod().periodStart.dayOfWeek;
        if (dayOfWeek !== undefined) {
            return dayOfWeek;
        }
        else {
            throw new Error('day of week is not set although it should be');
        }
    };
    /**
     * @param {?} style
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getMonthNames = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        // TODO: implement this properly, taking calendar format and locale into account
        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
    };
    /**
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getDateNames = /**
     * @return {?}
     */
    function () {
        // TODO: implement this properly, taking calendar format and locale into account
        /** @type {?} */
        var dateNames = [];
        for (var i = 1; i <= 31; i++) {
            dateNames.push(String(i));
        }
        return dateNames;
    };
    /**
     * @param {?} style
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getDayOfWeekNames = /**
     * @param {?} style
     * @return {?}
     */
    function (style) {
        // TODO: implement this properly, taking calendar format and locale into account
        return ['Sun', 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat'];
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getYearName = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return String(date.toCalendarPeriod().periodStart.year);
    };
    /**
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getFirstDayOfWeek = /**
     * @return {?}
     */
    function () {
        // TODO: implement this properly, taking calendar format into account
        return 0;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.getNumDaysInMonth = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var calendarPeriod = date.toCalendarPeriod();
        return date.daysInMonth(calendarPeriod.periodStart);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.clone = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        /** @type {?} */
        var jdnPeriod = date.toJDNPeriod();
        switch (this._activeCalendarFormat) {
            case 'Gregorian':
                return new GregorianCalendarDate(jdnPeriod);
            case 'Julian':
                return new JulianCalendarDate(jdnPeriod);
        }
    };
    /**
     * Creates a date in the specified calendar format.
     *
     * @param year the date's year.
     * @param month the date's month (0-based index).
     * @param date the date's day.
     * @param calendar the calendar format to be used.
     * @returns a date in the specified calendar format.
     */
    /**
     * Creates a date in the specified calendar format.
     *
     * @private
     * @param {?} year the date's year.
     * @param {?} month the date's month (0-based index).
     * @param {?} date the date's day.
     * @param {?} calendar the calendar format to be used.
     * @return {?} a date in the specified calendar format.
     */
    JDNConvertibleCalendarDateAdapter.prototype.createCalendarDate = /**
     * Creates a date in the specified calendar format.
     *
     * @private
     * @param {?} year the date's year.
     * @param {?} month the date's month (0-based index).
     * @param {?} date the date's day.
     * @param {?} calendar the calendar format to be used.
     * @return {?} a date in the specified calendar format.
     */
    function (year, month, date, calendar) {
        // month param is 0 indexed, but we use 1 based index for months
        /** @type {?} */
        var calDate = new CalendarDate(year, month + 1, date);
        switch (calendar) {
            case 'Gregorian':
                return new GregorianCalendarDate(new CalendarPeriod(calDate, calDate));
            case 'Julian':
                return new JulianCalendarDate(new CalendarPeriod(calDate, calDate));
        }
    };
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.createDate = /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function (year, month, date) {
        // create a date in the active calendar format
        return this.createCalendarDate(year, month, date, this._activeCalendarFormat);
    };
    /**
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.today = /**
     * @return {?}
     */
    function () {
        // get today's date from the native JS Date object
        /** @type {?} */
        var today = new Date();
        /** @type {?} */
        var year = today.getFullYear();
        // 0 based month
        /** @type {?} */
        var month = today.getMonth();
        // day of month, 1 based index
        /** @type {?} */
        var day = today.getDate();
        // create a Gregorian calendar date from the native JS object
        // month used a 1 based index
        /** @type {?} */
        var calDate = new CalendarDate(year, month + 1, day);
        /** @type {?} */
        var dateGregorian = new GregorianCalendarDate(new CalendarPeriod(calDate, calDate));
        // convert the date to the active calendar format
        /** @type {?} */
        var date = this.convertCalendarFormat(dateGregorian, this._activeCalendarFormat);
        return date;
    };
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.parse = /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    function (value, parseFormat) {
        /** @type {?} */
        var date;
        if (parseFormat !== undefined && typeof parseFormat === 'string' && JDNConvertibleCalendarDateAdapter.parsableDateFormats.indexOf(parseFormat) !== -1) {
            switch (parseFormat) {
                case JDNConvertibleCalendarDateAdapter.DD_MM_YYYY: {
                    /** @type {?} */
                    var dateStringRegex = JDNConvertibleCalendarDateAdapter.dateFormatRegexes[parseFormat];
                    /** @type {?} */
                    var parsed = dateStringRegex.exec(value);
                    if (parsed !== null) {
                        // index 0 is the whole match
                        // month index must be 0 based
                        date = this.createDate(parseInt(parsed[3]), parseInt(parsed[2]) - 1, parseInt(parsed[1]));
                        break;
                    }
                    else {
                        console.log("Error: parsing of date string failed: " + value);
                        return null;
                    }
                }
                default: {
                    console.log("Error: supported parsable format was not handled correctly: " + parseFormat);
                    return null;
                }
            }
        }
        else {
            console.log("Error: unknown parseFormat " + parseFormat);
            return null;
        }
        return date;
    };
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.format = /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    function (date, displayFormat) {
        /** @type {?} */
        var dateString = '';
        if (displayFormat !== undefined && typeof displayFormat === 'string' && JDNConvertibleCalendarDateAdapter.displayDateFormats.lastIndexOf(displayFormat) !== -1) {
            /** @type {?} */
            var calendarPeriod = date.toCalendarPeriod();
            switch (displayFormat) {
                case JDNConvertibleCalendarDateAdapter.DD_MM_YYYY: {
                    dateString =
                        JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.day, 2) + "-" + JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.month, 2) + "-" + JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.year, 4);
                    break;
                }
                case JDNConvertibleCalendarDateAdapter.MM_YYYY: {
                    dateString = JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.month, 2) + "-" + JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.year, 4);
                    break;
                }
                default: {
                    console.log("Error: supported display format was not handled correctly: " + displayFormat);
                }
            }
        }
        else {
            console.log("Error: unknown displayFormat " + displayFormat);
        }
        return dateString;
    };
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.addCalendarYears = /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    function (date, years) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        /** @type {?} */
        var dateMod = this.clone(date);
        dateMod.transposePeriodByYear(years);
        return dateMod;
    };
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.addCalendarMonths = /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    function (date, months) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatMonthView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatMonthView
        /** @type {?} */
        var dateMod = this.clone(date);
        dateMod.transposePeriodByMonth(months);
        return dateMod;
    };
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.addCalendarDays = /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    function (date, days) {
        // another instance has to be returned, otherwise events do not work correctly
        // another instance has to be returned, otherwise events do not work correctly
        /** @type {?} */
        var dateMod = this.clone(date);
        dateMod.transposePeriodByDay(days);
        return dateMod;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.toIso8601 = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // use Gregorian
        /** @type {?} */
        var gregorianCal = date.convertCalendar('Gregorian');
        /** @type {?} */
        var gregorianCalPeriod = gregorianCal.toCalendarPeriod();
        console.log('to iso');
        return JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.year, 4) + "-" + JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.month, 2) + "-" + JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.day, 2);
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.isDateInstance = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return (obj instanceof JDNConvertibleCalendar);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.isValid = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        // TODO: implement this properly
        return true;
    };
    /**
     * @return {?}
     */
    JDNConvertibleCalendarDateAdapter.prototype.invalid = /**
     * @return {?}
     */
    function () {
        // TODO: create an invalid instance? For testing?
        return this.today();
    };
    JDNConvertibleCalendarDateAdapter.DD_MM_YYYY = 'DD-MM-YYYY';
    JDNConvertibleCalendarDateAdapter.MM_YYYY = 'MM-YYYY';
    JDNConvertibleCalendarDateAdapter.displayDateFormats = [JDNConvertibleCalendarDateAdapter.DD_MM_YYYY, JDNConvertibleCalendarDateAdapter.MM_YYYY];
    JDNConvertibleCalendarDateAdapter.parsableDateFormats = [JDNConvertibleCalendarDateAdapter.DD_MM_YYYY];
    JDNConvertibleCalendarDateAdapter.dateFormatRegexes = {
        'DD-MM-YYYY': new RegExp('^(\\d?\\d)-(\\d?\\d)-(\\d{4})')
    };
    JDNConvertibleCalendarDateAdapter.decorators = [
        { type: Injectable }
    ];
    return JDNConvertibleCalendarDateAdapter;
}(DateAdapter));
export { JDNConvertibleCalendarDateAdapter };
if (false) {
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.DD_MM_YYYY;
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.MM_YYYY;
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.displayDateFormats;
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.parsableDateFormats;
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.dateFormatRegexes;
    /**
     * @type {?}
     * @private
     */
    JDNConvertibleCalendarDateAdapter.prototype._activeCalendarFormat;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiamRuY29udmVydGlibGUtY2FsZW5kYXItZGF0ZS1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vamRuY29udmVydGlibGVjYWxlbmRhcmRhdGVhZGFwdGVyLyIsInNvdXJjZXMiOlsibGliL2pkbmNvbnZlcnRpYmxlLWNhbGVuZGFyLWRhdGUtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDOUMsT0FBTyxFQUNMLFlBQVksRUFDWixjQUFjLEVBQ2QscUJBQXFCLEVBQ3JCLHNCQUFzQixFQUd0QixrQkFBa0IsRUFDbkIsTUFBTSx3QkFBd0IsQ0FBQztBQUdoQztJQU11RCw2REFBbUM7SUFOMUY7UUFBQSxxRUE2VkM7O1FBeFVTLDJCQUFxQixHQUFHLFdBQVcsQ0FBQzs7SUF3VTlDLENBQUM7SUF0VUMsc0JBQUksbUVBQW9COzs7O1FBQXhCO1lBQ0UsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUM7UUFDcEMsQ0FBQzs7O09BQUE7SUFFRDs7Ozs7O09BTUc7Ozs7Ozs7OztJQUNZLHdEQUFzQjs7Ozs7Ozs7SUFBckMsVUFBc0MsR0FBVyxFQUFFLE1BQWM7O1lBRXpELGFBQWEsR0FBRyxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU07UUFFakQsSUFBSSxhQUFhLEdBQUcsQ0FBQyxFQUFFOztnQkFDakIsWUFBWSxHQUFHLEVBQUU7WUFDckIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMsWUFBWSxJQUFJLEdBQUcsQ0FBQzthQUNyQjtZQUVELE9BQU8sS0FBRyxZQUFZLEdBQUcsR0FBSyxDQUFDO1NBRWhDO2FBQU07WUFDTCxPQUFPLE1BQU0s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RUFBRSxJQUFJLE1BQU0sQ0FBQywrQkFBK0IsQ0FBQztLQUMxRCxDQUFDOztnQkFsQkgsVUFBVTs7SUE2Vlgsd0NBQUM7Q0FBQSxBQTdWRCxDQU11RCxXQUFXLEdBdVZqRTtTQXZWWSxpQ0FBaUM7Ozs7OztJQUU1Qyw2Q0FBa0Q7Ozs7O0lBRWxELDBDQUE0Qzs7Ozs7SUFFNUMscURBQXVJOzs7OztJQUV2SSxzREFBNkY7Ozs7O0lBRTdGLG9EQUVFOzs7OztJQUdGLGtFQUE0QyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgwqkgMjAxNyBMdWthcyBSb3NlbnRoYWxlciwgQmVuamFtaW4gR2VlciwgSXZhbiBTdWJvdGljLFxuICogVG9iaWFzIFNjaHdlaXplciwgQW5kcsOpIEtpbGNoZW5tYW5uLCBhbmQgU2VwaWRlaCBBbGFzc2kuXG4gKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgSkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLlxuICpcbiAqIEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlciBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWRcbiAqIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlciBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWNcbiAqIExpY2Vuc2UgYWxvbmcgd2l0aCBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cblxuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0ZUFkYXB0ZXJ9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCB7XG4gIENhbGVuZGFyRGF0ZSxcbiAgQ2FsZW5kYXJQZXJpb2QsXG4gIEdyZWdvcmlhbkNhbGVuZGFyRGF0ZSxcbiAgSkROQ29udmVydGlibGVDYWxlbmRhcixcbiAgSkROQ29udmVydGlibGVDb252ZXJzaW9uTW9kdWxlLFxuICBKRE5QZXJpb2QsXG4gIEp1bGlhbkNhbGVuZGFyRGF0ZVxufSBmcm9tICdqZG5jb252ZXJ0aWJsZWNhbGVuZGFyJztcblxuXG5ASW5qZWN0YWJsZSgpXG4vKipcbiAqIEltcGxlbWVudHMgYERhdGVBZGFwdGVyYCBmb3IgYEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJgLlxuICpcbiAqIGBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyYCBzdXBwb3J0cyBwZXJpb2RzIChkYXRlcyB3aXRoIGRpZmZlcmVudCBwcmVjaXNpb25zKSwgYnV0IGhlcmUgb25seSBleGFjdCBkYXlzIGFyZSBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAqL1xuZXhwb3J0IGNsYXNzIEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlciBleHRlbmRzIERhdGVBZGFwdGVyPEpETkNvbnZlcnRpYmxlQ2FsZW5kYXI+IHtcblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERF9NTV9ZWVlZID0gJ0RELU1NLVlZWVknO1xuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IE1NX1lZWVkgPSAnTU0tWVlZWSc7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZGlzcGxheURhdGVGb3JtYXRzID0gW0pETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5ERF9NTV9ZWVlZLCBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIuTU1fWVlZWV07XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcGFyc2FibGVEYXRlRm9ybWF0cyA9IFtKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIuRERfTU1fWVlZWV07XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgZGF0ZUZvcm1hdFJlZ2V4ZXMgPSB7XG4gICAgJ0RELU1NLVlZWVknOiBuZXcgUmVnRXhwKCdeKFxcXFxkP1xcXFxkKS0oXFxcXGQ/XFxcXGQpLShcXFxcZHs0fSknKVxuICB9O1xuXG4gIC8vIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNhbGVuZGFyIGZvcm1hdFxuICBwcml2YXRlIF9hY3RpdmVDYWxlbmRhckZvcm1hdCA9ICdHcmVnb3JpYW4nO1xuXG4gIGdldCBhY3RpdmVDYWxlbmRhckZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ2FsZW5kYXJGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBsZWFkaW5nIHplcm9zIHRvIGEgZ2l2ZW4gbnVtYmVyIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0gbnVtIHRoZSBnaXZlbiBudW1iZXIuXG4gICAqIEBwYXJhbSBkaWdpdHMgdGhlIG51bWJlciBvZiBleHBlY3RlZCBkaWdpdHMuXG4gICAqIEByZXR1cm5zIHN0cmluZyBjb250YWluaW5nIGxlYWRpbmcgemVyb3MuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBhZGRMZWFkaW5nWmVyb1RvTnVtYmVyKG51bTogbnVtYmVyLCBkaWdpdHM6IG51bWJlcik6IHN0cmluZyB7XG5cbiAgICBjb25zdCBtaXNzaW5nRGlnaXRzID0gZGlnaXRzIC0gU3RyaW5nKG51bSkubGVuZ3RoO1xuXG4gICAgaWYgKG1pc3NpbmdEaWdpdHMgPiAwKSB7XG4gICAgICBsZXQgbGVhZGluZ1plcm9zID0gJyc7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pc3NpbmdEaWdpdHM7IGkrKykge1xuICAgICAgICBsZWFkaW5nWmVyb3MgKz0gJzAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7bGVhZGluZ1plcm9zfSR7bnVtfWA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFN0cmluZyhudW0pO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBkYXRlIHRvIHRoZSBpbmRpY2F0ZWQgY2FsZW5kYXIgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSBmb3JtYXQgdGhlIGNhbGVuZGFyIGZvcm1hdCB0byBjb252ZXJ0IHRvLlxuICAgKiBAcmV0dXJucyBjb252ZXJ0ZWQgZGF0ZS5cbiAgICovXG4gIGNvbnZlcnRDYWxlbmRhckZvcm1hdChkYXRlOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyLCBmb3JtYXQ6IHN0cmluZyk6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIge1xuXG4gICAgLy8gYW5vdGhlciBpbnN0YW5jZSBoYXMgdG8gYmUgcmV0dXJuZWQsIG90aGVyd2lzZSBcImFjdGl2ZURhdGVcIiBzZXQgbWV0aG9kIGlzIG5vdCB0cmlnZ2VyZWQgZm9yIE1hdFllYXJWaWV3XG5cbiAgICBjb25zdCBkYXRlTW9kID0gdGhpcy5jbG9uZShkYXRlKTtcblxuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlICdHcmVnb3JpYW4nOlxuICAgICAgICB0aGlzLl9hY3RpdmVDYWxlbmRhckZvcm1hdCA9ICdHcmVnb3JpYW4nO1xuICAgICAgICByZXR1cm4gZGF0ZU1vZC5jb252ZXJ0Q2FsZW5kYXIoJ0dyZWdvcmlhbicpO1xuXG4gICAgICBjYXNlICdKdWxpYW4nOlxuICAgICAgICB0aGlzLl9hY3RpdmVDYWxlbmRhckZvcm1hdCA9ICdKdWxpYW4nO1xuICAgICAgICByZXR1cm4gZGF0ZU1vZC5jb252ZXJ0Q2FsZW5kYXIoJ0p1bGlhbicpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBpbnZhbGlkIGZvcm1hdFxuICAgICAgICByZXR1cm4gZGF0ZU1vZDtcbiAgICB9XG4gIH1cblxuICBnZXRZZWFyKGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIpOiBudW1iZXIge1xuICAgIHJldHVybiBkYXRlLnRvQ2FsZW5kYXJQZXJpb2QoKS5wZXJpb2RTdGFydC55ZWFyO1xuICB9XG5cbiAgZ2V0TW9udGgoZGF0ZTogSkROQ29udmVydGlibGVDYWxlbmRhcik6IG51bWJlciB7XG4gICAgLy8gcmV0dXJuIDAgaW5kZXggYmFzZWQgbW9udGhcbiAgICByZXR1cm4gZGF0ZS50b0NhbGVuZGFyUGVyaW9kKCkucGVyaW9kU3RhcnQubW9udGggLSAxO1xuICB9XG5cbiAgZ2V0RGF0ZShkYXRlOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gZGF0ZS50b0NhbGVuZGFyUGVyaW9kKCkucGVyaW9kU3RhcnQuZGF5O1xuICB9XG5cbiAgZ2V0RGF5T2ZXZWVrKGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIpOiBudW1iZXIge1xuXG4gICAgLy8gZGF5T2ZXZWVrIGlzIGFuIG9wdGlvbmFsIGNsYXNzIG1lbWJlciwgYnV0IGFsd2F5cyBzZXQgd2hlbiByZXR1cm5lZCBieSB0aGlzIG1ldGhvZFxuICAgIGNvbnN0IGRheU9mV2VlazogbnVtYmVyIHwgdW5kZWZpbmVkID0gZGF0ZS50b0NhbGVuZGFyUGVyaW9kKCkucGVyaW9kU3RhcnQuZGF5T2ZXZWVrO1xuXG4gICAgaWYgKGRheU9mV2VlayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZGF5T2ZXZWVrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RheSBvZiB3ZWVrIGlzIG5vdCBzZXQgYWx0aG91Z2ggaXQgc2hvdWxkIGJlJyk7XG4gICAgfVxuXG4gIH1cblxuICBnZXRNb250aE5hbWVzKHN0eWxlOiAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdycpOiBzdHJpbmdbXSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgcHJvcGVybHksIHRha2luZyBjYWxlbmRhciBmb3JtYXQgYW5kIGxvY2FsZSBpbnRvIGFjY291bnRcbiAgICByZXR1cm4gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWcnLCAnU2VwdCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICB9XG5cbiAgZ2V0RGF0ZU5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJseSwgdGFraW5nIGNhbGVuZGFyIGZvcm1hdCBhbmQgbG9jYWxlIGludG8gYWNjb3VudFxuICAgIGNvbnN0IGRhdGVOYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSAzMTsgaSsrKSB7XG4gICAgICBkYXRlTmFtZXMucHVzaChTdHJpbmcoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlTmFtZXM7XG4gIH1cblxuICBnZXREYXlPZldlZWtOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHRoaXMgcHJvcGVybHksIHRha2luZyBjYWxlbmRhciBmb3JtYXQgYW5kIGxvY2FsZSBpbnRvIGFjY291bnRcbiAgICByZXR1cm4gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1cicsICdGcmknLCAnU2F0J107XG4gIH1cblxuICBnZXRZZWFyTmFtZShkYXRlOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gU3RyaW5nKGRhdGUudG9DYWxlbmRhclBlcmlvZCgpLnBlcmlvZFN0YXJ0LnllYXIpO1xuICB9XG5cbiAgZ2V0Rmlyc3REYXlPZldlZWsoKTogbnVtYmVyIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJseSwgdGFraW5nIGNhbGVuZGFyIGZvcm1hdCBpbnRvIGFjY291bnRcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldE51bURheXNJbk1vbnRoKGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGNhbGVuZGFyUGVyaW9kID0gZGF0ZS50b0NhbGVuZGFyUGVyaW9kKCk7XG5cbiAgICByZXR1cm4gZGF0ZS5kYXlzSW5Nb250aChjYWxlbmRhclBlcmlvZC5wZXJpb2RTdGFydCk7XG4gIH1cblxuICBjbG9uZShkYXRlOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyKTogSkROQ29udmVydGlibGVDYWxlbmRhciB7XG5cbiAgICBjb25zdCBqZG5QZXJpb2QgPSBkYXRlLnRvSkROUGVyaW9kKCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX2FjdGl2ZUNhbGVuZGFyRm9ybWF0KSB7XG4gICAgICBjYXNlICdHcmVnb3JpYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShqZG5QZXJpb2QpO1xuXG4gICAgICBjYXNlICdKdWxpYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEp1bGlhbkNhbGVuZGFyRGF0ZShqZG5QZXJpb2QpO1xuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkYXRlIGluIHRoZSBzcGVjaWZpZWQgY2FsZW5kYXIgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0geWVhciB0aGUgZGF0ZSdzIHllYXIuXG4gICAqIEBwYXJhbSBtb250aCB0aGUgZGF0ZSdzIG1vbnRoICgwLWJhc2VkIGluZGV4KS5cbiAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUncyBkYXkuXG4gICAqIEBwYXJhbSBjYWxlbmRhciB0aGUgY2FsZW5kYXIgZm9ybWF0IHRvIGJlIHVzZWQuXG4gICAqIEByZXR1cm5zIGEgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGNhbGVuZGFyIGZvcm1hdC5cbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQ2FsZW5kYXJEYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyLCBjYWxlbmRhcjogc3RyaW5nKTogSkROQ29udmVydGlibGVDYWxlbmRhciB7XG4gICAgLy8gbW9udGggcGFyYW0gaXMgMCBpbmRleGVkLCBidXQgd2UgdXNlIDEgYmFzZWQgaW5kZXggZm9yIG1vbnRoc1xuICAgIGNvbnN0IGNhbERhdGUgPSBuZXcgQ2FsZW5kYXJEYXRlKHllYXIsIG1vbnRoICsgMSwgZGF0ZSk7XG5cbiAgICBzd2l0Y2ggKGNhbGVuZGFyKSB7XG4gICAgICBjYXNlICdHcmVnb3JpYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEdyZWdvcmlhbkNhbGVuZGFyRGF0ZShuZXcgQ2FsZW5kYXJQZXJpb2QoY2FsRGF0ZSwgY2FsRGF0ZSkpO1xuXG4gICAgICBjYXNlICdKdWxpYW4nOlxuICAgICAgICByZXR1cm4gbmV3IEp1bGlhbkNhbGVuZGFyRGF0ZShuZXcgQ2FsZW5kYXJQZXJpb2QoY2FsRGF0ZSwgY2FsRGF0ZSkpO1xuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZURhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyIHtcblxuICAgIC8vIGNyZWF0ZSBhIGRhdGUgaW4gdGhlIGFjdGl2ZSBjYWxlbmRhciBmb3JtYXRcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVDYWxlbmRhckRhdGUoeWVhciwgbW9udGgsIGRhdGUsIHRoaXMuX2FjdGl2ZUNhbGVuZGFyRm9ybWF0KTtcblxuICB9XG5cbiAgdG9kYXkoKTogSkROQ29udmVydGlibGVDYWxlbmRhciB7XG5cbiAgICAvLyBnZXQgdG9kYXkncyBkYXRlIGZyb20gdGhlIG5hdGl2ZSBKUyBEYXRlIG9iamVjdFxuICAgIGNvbnN0IHRvZGF5OiBEYXRlID0gbmV3IERhdGUoKTtcblxuICAgIGNvbnN0IHllYXIgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xuXG4gICAgLy8gMCBiYXNlZCBtb250aFxuICAgIGNvbnN0IG1vbnRoID0gdG9kYXkuZ2V0TW9udGgoKTtcblxuICAgIC8vIGRheSBvZiBtb250aCwgMSBiYXNlZCBpbmRleFxuICAgIGNvbnN0IGRheSA9IHRvZGF5LmdldERhdGUoKTtcblxuICAgIC8vIGNyZWF0ZSBhIEdyZWdvcmlhbiBjYWxlbmRhciBkYXRlIGZyb20gdGhlIG5hdGl2ZSBKUyBvYmplY3RcbiAgICAvLyBtb250aCB1c2VkIGEgMSBiYXNlZCBpbmRleFxuICAgIGNvbnN0IGNhbERhdGUgPSBuZXcgQ2FsZW5kYXJEYXRlKHllYXIsIG1vbnRoICsgMSwgZGF5KTtcblxuICAgIGNvbnN0IGRhdGVHcmVnb3JpYW4gPSBuZXcgR3JlZ29yaWFuQ2FsZW5kYXJEYXRlKG5ldyBDYWxlbmRhclBlcmlvZChjYWxEYXRlLCBjYWxEYXRlKSk7XG5cbiAgICAvLyBjb252ZXJ0IHRoZSBkYXRlIHRvIHRoZSBhY3RpdmUgY2FsZW5kYXIgZm9ybWF0XG4gICAgY29uc3QgZGF0ZTogSkROQ29udmVydGlibGVDYWxlbmRhciA9IHRoaXMuY29udmVydENhbGVuZGFyRm9ybWF0KGRhdGVHcmVnb3JpYW4sIHRoaXMuX2FjdGl2ZUNhbGVuZGFyRm9ybWF0KTtcblxuICAgIHJldHVybiBkYXRlO1xuXG4gIH1cblxuICBwYXJzZSh2YWx1ZTogYW55LCBwYXJzZUZvcm1hdDogYW55KTogSkROQ29udmVydGlibGVDYWxlbmRhciB8IG51bGwge1xuXG4gICAgbGV0IGRhdGU7XG4gICAgaWYgKHBhcnNlRm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhcnNlRm9ybWF0ID09PSAnc3RyaW5nJyAmJiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIucGFyc2FibGVEYXRlRm9ybWF0cy5pbmRleE9mKHBhcnNlRm9ybWF0KSAhPT0gLTEpIHtcblxuICAgICAgc3dpdGNoIChwYXJzZUZvcm1hdCkge1xuICAgICAgICBjYXNlIEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5ERF9NTV9ZWVlZOiB7XG5cbiAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nUmVnZXggPSBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIuZGF0ZUZvcm1hdFJlZ2V4ZXNbcGFyc2VGb3JtYXRdO1xuXG4gICAgICAgICAgY29uc3QgcGFyc2VkOiBBcnJheTxhbnk+IHwgbnVsbCA9IGRhdGVTdHJpbmdSZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgIGlmIChwYXJzZWQgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy8gaW5kZXggMCBpcyB0aGUgd2hvbGUgbWF0Y2hcblxuICAgICAgICAgICAgLy8gbW9udGggaW5kZXggbXVzdCBiZSAwIGJhc2VkXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5jcmVhdGVEYXRlKHBhcnNlSW50KHBhcnNlZFszXSksIHBhcnNlSW50KHBhcnNlZFsyXSkgLSAxLCBwYXJzZUludChwYXJzZWRbMV0pKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvcjogcGFyc2luZyBvZiBkYXRlIHN0cmluZyBmYWlsZWQ6ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvcjogc3VwcG9ydGVkIHBhcnNhYmxlIGZvcm1hdCB3YXMgbm90IGhhbmRsZWQgY29ycmVjdGx5OiAke3BhcnNlRm9ybWF0fWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgRXJyb3I6IHVua25vd24gcGFyc2VGb3JtYXQgJHtwYXJzZUZvcm1hdH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgZm9ybWF0KGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIsIGRpc3BsYXlGb3JtYXQ6IGFueSk6IHN0cmluZyB7XG4gICAgbGV0IGRhdGVTdHJpbmcgPSAnJztcbiAgICBpZiAoZGlzcGxheUZvcm1hdCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkaXNwbGF5Rm9ybWF0ID09PSAnc3RyaW5nJyAmJiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyRGF0ZUFkYXB0ZXIuZGlzcGxheURhdGVGb3JtYXRzLmxhc3RJbmRleE9mKGRpc3BsYXlGb3JtYXQpICE9PSAtMSkge1xuXG4gICAgICBjb25zdCBjYWxlbmRhclBlcmlvZCA9IGRhdGUudG9DYWxlbmRhclBlcmlvZCgpO1xuXG4gICAgICBzd2l0Y2ggKGRpc3BsYXlGb3JtYXQpIHtcblxuICAgICAgICBjYXNlIEpETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5ERF9NTV9ZWVlZOiB7XG5cbiAgICAgICAgICBkYXRlU3RyaW5nID1cbiAgICAgICAgICAgIGAke0pETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5hZGRMZWFkaW5nWmVyb1RvTnVtYmVyKGNhbGVuZGFyUGVyaW9kLnBlcmlvZFN0YXJ0LmRheSwgMil9LSR7SkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLmFkZExlYWRpbmdaZXJvVG9OdW1iZXIoY2FsZW5kYXJQZXJpb2QucGVyaW9kU3RhcnQubW9udGgsIDIpfS0ke0pETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5hZGRMZWFkaW5nWmVyb1RvTnVtYmVyKGNhbGVuZGFyUGVyaW9kLnBlcmlvZFN0YXJ0LnllYXIsIDQpfWA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLk1NX1lZWVk6IHtcbiAgICAgICAgICBkYXRlU3RyaW5nID0gYCR7SkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLmFkZExlYWRpbmdaZXJvVG9OdW1iZXIoY2FsZW5kYXJQZXJpb2QucGVyaW9kU3RhcnQubW9udGgsIDIpfS0ke0pETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5hZGRMZWFkaW5nWmVyb1RvTnVtYmVyKGNhbGVuZGFyUGVyaW9kLnBlcmlvZFN0YXJ0LnllYXIsIDQpfWA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEVycm9yOiBzdXBwb3J0ZWQgZGlzcGxheSBmb3JtYXQgd2FzIG5vdCBoYW5kbGVkIGNvcnJlY3RseTogJHtkaXNwbGF5Rm9ybWF0fWApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhgRXJyb3I6IHVua25vd24gZGlzcGxheUZvcm1hdCAke2Rpc3BsYXlGb3JtYXR9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGVTdHJpbmc7XG4gIH1cblxuICBhZGRDYWxlbmRhclllYXJzKGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIsIHllYXJzOiBudW1iZXIpOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyIHtcblxuICAgIC8vIGFub3RoZXIgaW5zdGFuY2UgaGFzIHRvIGJlIHJldHVybmVkLCBvdGhlcndpc2UgXCJhY3RpdmVEYXRlXCIgc2V0IG1ldGhvZCBpcyBub3QgdHJpZ2dlcmVkIGZvciBNYXRZZWFyVmlld1xuXG4gICAgY29uc3QgZGF0ZU1vZCA9IHRoaXMuY2xvbmUoZGF0ZSk7XG5cbiAgICBkYXRlTW9kLnRyYW5zcG9zZVBlcmlvZEJ5WWVhcih5ZWFycyk7XG5cbiAgICByZXR1cm4gZGF0ZU1vZDtcblxuICB9XG5cbiAgYWRkQ2FsZW5kYXJNb250aHMoZGF0ZTogSkROQ29udmVydGlibGVDYWxlbmRhciwgbW9udGhzOiBudW1iZXIpOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyIHtcblxuICAgIC8vIGFub3RoZXIgaW5zdGFuY2UgaGFzIHRvIGJlIHJldHVybmVkLCBvdGhlcndpc2UgXCJhY3RpdmVEYXRlXCIgc2V0IG1ldGhvZCBpcyBub3QgdHJpZ2dlcmVkIGZvciBNYXRNb250aFZpZXdcblxuICAgIGNvbnN0IGRhdGVNb2QgPSB0aGlzLmNsb25lKGRhdGUpO1xuXG4gICAgZGF0ZU1vZC50cmFuc3Bvc2VQZXJpb2RCeU1vbnRoKG1vbnRocyk7XG5cbiAgICByZXR1cm4gZGF0ZU1vZDtcbiAgfVxuXG4gIGFkZENhbGVuZGFyRGF5cyhkYXRlOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyLCBkYXlzOiBudW1iZXIpOiBKRE5Db252ZXJ0aWJsZUNhbGVuZGFyIHtcblxuICAgIC8vIGFub3RoZXIgaW5zdGFuY2UgaGFzIHRvIGJlIHJldHVybmVkLCBvdGhlcndpc2UgZXZlbnRzIGRvIG5vdCB3b3JrIGNvcnJlY3RseVxuXG4gICAgY29uc3QgZGF0ZU1vZCA9IHRoaXMuY2xvbmUoZGF0ZSk7XG5cbiAgICBkYXRlTW9kLnRyYW5zcG9zZVBlcmlvZEJ5RGF5KGRheXMpO1xuXG4gICAgcmV0dXJuIGRhdGVNb2Q7XG4gIH1cblxuICB0b0lzbzg2MDEoZGF0ZTogSkROQ29udmVydGlibGVDYWxlbmRhcikge1xuXG4gICAgLy8gdXNlIEdyZWdvcmlhblxuICAgIGNvbnN0IGdyZWdvcmlhbkNhbCA9IGRhdGUuY29udmVydENhbGVuZGFyKCdHcmVnb3JpYW4nKTtcblxuICAgIGNvbnN0IGdyZWdvcmlhbkNhbFBlcmlvZCA9IGdyZWdvcmlhbkNhbC50b0NhbGVuZGFyUGVyaW9kKCk7XG5cbiAgICBjb25zb2xlLmxvZygndG8gaXNvJyk7XG5cbiAgICByZXR1cm4gYCR7SkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLmFkZExlYWRpbmdaZXJvVG9OdW1iZXIoZ3JlZ29yaWFuQ2FsUGVyaW9kLnBlcmlvZFN0YXJ0LnllYXIsIDQpfS0ke0pETkNvbnZlcnRpYmxlQ2FsZW5kYXJEYXRlQWRhcHRlci5hZGRMZWFkaW5nWmVyb1RvTnVtYmVyKGdyZWdvcmlhbkNhbFBlcmlvZC5wZXJpb2RTdGFydC5tb250aCwgMil9LSR7SkROQ29udmVydGlibGVDYWxlbmRhckRhdGVBZGFwdGVyLmFkZExlYWRpbmdaZXJvVG9OdW1iZXIoZ3JlZ29yaWFuQ2FsUGVyaW9kLnBlcmlvZFN0YXJ0LmRheSwgMil9YDtcblxuICB9XG5cblxuICBpc0RhdGVJbnN0YW5jZShvYmo6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgSkROQ29udmVydGlibGVDYWxlbmRhcik7XG4gIH1cblxuICBpc1ZhbGlkKGRhdGU6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIpOiBib29sZWFuIHtcbiAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdGhpcyBwcm9wZXJseVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkKCk6IEpETkNvbnZlcnRpYmxlQ2FsZW5kYXIge1xuICAgIC8vIFRPRE86IGNyZWF0ZSBhbiBpbnZhbGlkIGluc3RhbmNlPyBGb3IgdGVzdGluZz9cblxuICAgIHJldHVybiB0aGlzLnRvZGF5KCk7XG4gIH1cblxuXG59XG4iXX0=