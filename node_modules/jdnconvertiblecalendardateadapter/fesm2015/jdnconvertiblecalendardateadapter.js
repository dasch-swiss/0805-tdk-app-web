import { Injectable, NgModule } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material';
import { CalendarDate, CalendarPeriod, GregorianCalendarDate, JDNConvertibleCalendar, JulianCalendarDate } from 'jdnconvertiblecalendar';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Implements `DateAdapter` for `JDNConvertibleCalendar`.
 *
 * `JDNConvertibleCalendar` supports periods (dates with different precisions), but here only exact days are supported for now.
 */
class JDNConvertibleCalendarDateAdapter extends DateAdapter {
    constructor() {
        super(...arguments);
        // the currently active calendar format
        this._activeCalendarFormat = 'Gregorian';
    }
    /**
     * @return {?}
     */
    get activeCalendarFormat() {
        return this._activeCalendarFormat;
    }
    /**
     * Adds leading zeros to a given number and returns the resulting string.
     *
     * @private
     * @param {?} num the given number.
     * @param {?} digits the number of expected digits.
     * @return {?} string containing leading zeros.
     */
    static addLeadingZeroToNumber(num, digits) {
        /** @type {?} */
        const missingDigits = digits - String(num).length;
        if (missingDigits > 0) {
            /** @type {?} */
            let leadingZeros = '';
            for (let i = 0; i < missingDigits; i++) {
                leadingZeros += '0';
            }
            return `${leadingZeros}${num}`;
        }
        else {
            return String(num);
        }
    }
    /**
     * Converts the given date to the indicated calendar format.
     *
     * @param {?} date the date to be converted.
     * @param {?} format the calendar format to convert to.
     * @return {?} converted date.
     */
    convertCalendarFormat(date, format) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        /** @type {?} */
        const dateMod = this.clone(date);
        switch (format) {
            case 'Gregorian':
                this._activeCalendarFormat = 'Gregorian';
                return dateMod.convertCalendar('Gregorian');
            case 'Julian':
                this._activeCalendarFormat = 'Julian';
                return dateMod.convertCalendar('Julian');
            default:
                // invalid format
                return dateMod;
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYear(date) {
        return date.toCalendarPeriod().periodStart.year;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonth(date) {
        // return 0 index based month
        return date.toCalendarPeriod().periodStart.month - 1;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDate(date) {
        return date.toCalendarPeriod().periodStart.day;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getDayOfWeek(date) {
        // dayOfWeek is an optional class member, but always set when returned by this method
        /** @type {?} */
        const dayOfWeek = date.toCalendarPeriod().periodStart.dayOfWeek;
        if (dayOfWeek !== undefined) {
            return dayOfWeek;
        }
        else {
            throw new Error('day of week is not set although it should be');
        }
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getMonthNames(style) {
        // TODO: implement this properly, taking calendar format and locale into account
        return ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June', 'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];
    }
    /**
     * @return {?}
     */
    getDateNames() {
        // TODO: implement this properly, taking calendar format and locale into account
        /** @type {?} */
        const dateNames = [];
        for (let i = 1; i <= 31; i++) {
            dateNames.push(String(i));
        }
        return dateNames;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getDayOfWeekNames(style) {
        // TODO: implement this properly, taking calendar format and locale into account
        return ['Sun', 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat'];
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getYearName(date) {
        return String(date.toCalendarPeriod().periodStart.year);
    }
    /**
     * @return {?}
     */
    getFirstDayOfWeek() {
        // TODO: implement this properly, taking calendar format into account
        return 0;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNumDaysInMonth(date) {
        /** @type {?} */
        const calendarPeriod = date.toCalendarPeriod();
        return date.daysInMonth(calendarPeriod.periodStart);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    clone(date) {
        /** @type {?} */
        const jdnPeriod = date.toJDNPeriod();
        switch (this._activeCalendarFormat) {
            case 'Gregorian':
                return new GregorianCalendarDate(jdnPeriod);
            case 'Julian':
                return new JulianCalendarDate(jdnPeriod);
        }
    }
    /**
     * Creates a date in the specified calendar format.
     *
     * @private
     * @param {?} year the date's year.
     * @param {?} month the date's month (0-based index).
     * @param {?} date the date's day.
     * @param {?} calendar the calendar format to be used.
     * @return {?} a date in the specified calendar format.
     */
    createCalendarDate(year, month, date, calendar) {
        // month param is 0 indexed, but we use 1 based index for months
        /** @type {?} */
        const calDate = new CalendarDate(year, month + 1, date);
        switch (calendar) {
            case 'Gregorian':
                return new GregorianCalendarDate(new CalendarPeriod(calDate, calDate));
            case 'Julian':
                return new JulianCalendarDate(new CalendarPeriod(calDate, calDate));
        }
    }
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    createDate(year, month, date) {
        // create a date in the active calendar format
        return this.createCalendarDate(year, month, date, this._activeCalendarFormat);
    }
    /**
     * @return {?}
     */
    today() {
        // get today's date from the native JS Date object
        /** @type {?} */
        const today = new Date();
        /** @type {?} */
        const year = today.getFullYear();
        // 0 based month
        /** @type {?} */
        const month = today.getMonth();
        // day of month, 1 based index
        /** @type {?} */
        const day = today.getDate();
        // create a Gregorian calendar date from the native JS object
        // month used a 1 based index
        /** @type {?} */
        const calDate = new CalendarDate(year, month + 1, day);
        /** @type {?} */
        const dateGregorian = new GregorianCalendarDate(new CalendarPeriod(calDate, calDate));
        // convert the date to the active calendar format
        /** @type {?} */
        const date = this.convertCalendarFormat(dateGregorian, this._activeCalendarFormat);
        return date;
    }
    /**
     * @param {?} value
     * @param {?} parseFormat
     * @return {?}
     */
    parse(value, parseFormat) {
        /** @type {?} */
        let date;
        if (parseFormat !== undefined && typeof parseFormat === 'string' && JDNConvertibleCalendarDateAdapter.parsableDateFormats.indexOf(parseFormat) !== -1) {
            switch (parseFormat) {
                case JDNConvertibleCalendarDateAdapter.DD_MM_YYYY: {
                    /** @type {?} */
                    const dateStringRegex = JDNConvertibleCalendarDateAdapter.dateFormatRegexes[parseFormat];
                    /** @type {?} */
                    const parsed = dateStringRegex.exec(value);
                    if (parsed !== null) {
                        // index 0 is the whole match
                        // month index must be 0 based
                        date = this.createDate(parseInt(parsed[3]), parseInt(parsed[2]) - 1, parseInt(parsed[1]));
                        break;
                    }
                    else {
                        console.log(`Error: parsing of date string failed: ${value}`);
                        return null;
                    }
                }
                default: {
                    console.log(`Error: supported parsable format was not handled correctly: ${parseFormat}`);
                    return null;
                }
            }
        }
        else {
            console.log(`Error: unknown parseFormat ${parseFormat}`);
            return null;
        }
        return date;
    }
    /**
     * @param {?} date
     * @param {?} displayFormat
     * @return {?}
     */
    format(date, displayFormat) {
        /** @type {?} */
        let dateString = '';
        if (displayFormat !== undefined && typeof displayFormat === 'string' && JDNConvertibleCalendarDateAdapter.displayDateFormats.lastIndexOf(displayFormat) !== -1) {
            /** @type {?} */
            const calendarPeriod = date.toCalendarPeriod();
            switch (displayFormat) {
                case JDNConvertibleCalendarDateAdapter.DD_MM_YYYY: {
                    dateString =
                        `${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.day, 2)}-${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.month, 2)}-${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.year, 4)}`;
                    break;
                }
                case JDNConvertibleCalendarDateAdapter.MM_YYYY: {
                    dateString = `${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.month, 2)}-${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(calendarPeriod.periodStart.year, 4)}`;
                    break;
                }
                default: {
                    console.log(`Error: supported display format was not handled correctly: ${displayFormat}`);
                }
            }
        }
        else {
            console.log(`Error: unknown displayFormat ${displayFormat}`);
        }
        return dateString;
    }
    /**
     * @param {?} date
     * @param {?} years
     * @return {?}
     */
    addCalendarYears(date, years) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatYearView
        /** @type {?} */
        const dateMod = this.clone(date);
        dateMod.transposePeriodByYear(years);
        return dateMod;
    }
    /**
     * @param {?} date
     * @param {?} months
     * @return {?}
     */
    addCalendarMonths(date, months) {
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatMonthView
        // another instance has to be returned, otherwise "activeDate" set method is not triggered for MatMonthView
        /** @type {?} */
        const dateMod = this.clone(date);
        dateMod.transposePeriodByMonth(months);
        return dateMod;
    }
    /**
     * @param {?} date
     * @param {?} days
     * @return {?}
     */
    addCalendarDays(date, days) {
        // another instance has to be returned, otherwise events do not work correctly
        // another instance has to be returned, otherwise events do not work correctly
        /** @type {?} */
        const dateMod = this.clone(date);
        dateMod.transposePeriodByDay(days);
        return dateMod;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toIso8601(date) {
        // use Gregorian
        /** @type {?} */
        const gregorianCal = date.convertCalendar('Gregorian');
        /** @type {?} */
        const gregorianCalPeriod = gregorianCal.toCalendarPeriod();
        console.log('to iso');
        return `${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.year, 4)}-${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.month, 2)}-${JDNConvertibleCalendarDateAdapter.addLeadingZeroToNumber(gregorianCalPeriod.periodStart.day, 2)}`;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isDateInstance(obj) {
        return (obj instanceof JDNConvertibleCalendar);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    isValid(date) {
        // TODO: implement this properly
        return true;
    }
    /**
     * @return {?}
     */
    invalid() {
        // TODO: create an invalid instance? For testing?
        return this.today();
    }
}
JDNConvertibleCalendarDateAdapter.DD_MM_YYYY = 'DD-MM-YYYY';
JDNConvertibleCalendarDateAdapter.MM_YYYY = 'MM-YYYY';
JDNConvertibleCalendarDateAdapter.displayDateFormats = [JDNConvertibleCalendarDateAdapter.DD_MM_YYYY, JDNConvertibleCalendarDateAdapter.MM_YYYY];
JDNConvertibleCalendarDateAdapter.parsableDateFormats = [JDNConvertibleCalendarDateAdapter.DD_MM_YYYY];
JDNConvertibleCalendarDateAdapter.dateFormatRegexes = {
    'DD-MM-YYYY': new RegExp('^(\\d?\\d)-(\\d?\\d)-(\\d{4})')
};
JDNConvertibleCalendarDateAdapter.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAT_JDN_DATE_FORMATS = {
    parse: {
        dateInput: 'DD-MM-YYYY'
    },
    display: {
        dateInput: 'DD-MM-YYYY',
        monthYearLabel: 'MM-YYYY',
        dateA11yLabel: 'DD-MM-YYYY',
        monthYearA11yLabel: 'MM-YYYY'
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class JDNConvertibleCalendarDateAdapterModule {
}
JDNConvertibleCalendarDateAdapterModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: DateAdapter, useClass: JDNConvertibleCalendarDateAdapter, deps: [MAT_DATE_LOCALE] }
                ]
            },] }
];
const ɵ0 = MAT_JDN_DATE_FORMATS;
class MatJDNConvertibleCalendarDateAdapterModule {
}
MatJDNConvertibleCalendarDateAdapterModule.decorators = [
    { type: NgModule, args: [{
                imports: [JDNConvertibleCalendarDateAdapterModule],
                providers: [{ provide: MAT_DATE_FORMATS, useValue: ɵ0 }],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { JDNConvertibleCalendarDateAdapterModule, MatJDNConvertibleCalendarDateAdapterModule, JDNConvertibleCalendarDateAdapter, MAT_JDN_DATE_FORMATS as ɵa };

//# sourceMappingURL=jdnconvertiblecalendardateadapter.js.map